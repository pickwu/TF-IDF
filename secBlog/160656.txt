*本文原创作者：y0nLandroid，本文属FreeBuf原创奖励计划，未经许可禁止转载
1.写在开始
最近在学习梆梆壳，在调试的过程中遇到了反调试，很是苦恼，而且每次调试都会被中断，朋友发了篇帖子【1】介绍了其中的一个反调，学习后收获颇多，给我指明了方向，接下来再对其他反调试进行补充，若有疏漏之处请各位大佬批评指正。
2.反调试之时间线程检测
启动调试后是对帖子【1】的验证，过程大致如下：
运行brpt.py后一路F9,
... #下断点 # 内存中获取模块基地址 base = FindModule('linker'); #.text:00002464 BLX R4 addr = base + 0x2464; #该偏移值需要使用IDA静态查看linker模块的偏移值 #给linker下断点 AddBpt(addr); #在libc.so中对库函数下断点 AddBpt(LocByName('fopen')); AddBpt(LocByName('ptrace')); ...
当lr为pB54EB0CAE49198754C66F4A57BDB01DF函数时即为第一个反调试的线程创建处，然后会调用libDexHelper.so:pDD8ABF73B0AE99BD998BC5C954A74856，
再按一次F9即可断到帖子中提到的fopen函数处
执行完fopen后，回到调用函数libDexHelper.so:p8878CAA1006835C9D43174C88143BA8B处，然后在如下所示处下断点，F9执行到此处，观察寄存器的值并做相应的修改，具体思路就是要跳过libDexHelper.so:AEDC62A8 BLX sub_AEDA6ECC 这个函数调用即可。
执行完成后，会跳出调用函数，来到下图处将r0寄存器的值修改为0，或将指令#1改为#0即可。
并在p39D6B1EED99DC7E506A9D4E07BD58D3A处下断，
执行完之后F9，则会跳到p39D6B1EED99DC7E506A9D4E07BD58D3A处，
该函数功能类似kill，具体过程参考帖子【1】。
接下来通过静态分析知道了时间线程的创建点，如下所示：
具体的时间检测函数如下：
其中主要就是调用了gettimeofday函数，获取时间，然后再做如下比较：
不满足条件则kill掉,
以上便是时间检测的功能了。
3.反调试之ptrace检测
接下来是ptrace检测函数，通过静态分析ptrace被调用了3次，首先进行PTRACE_ATTACH，第二次调用后和0进行比较，最后进行PTRACE_DETACH，如下所示：
另一处case 13会调用pF77EA32766D841ED6BD10130E181CB0D()也是ptrace检测，
在p9392640B2E38B72373213C945704CA08处也调用了ptrace检测，
具体函数如下所示:
其中p1EBFB58D66C99CAD7405904C9B93559D()->p39D6B1EED99DC7E506A9D4E07BD58D3A。
4.函数大致流程
经过上述分析，整理大致调用流程如下(随手画的)：
5.Hook检测之Xposed检测
对于Xposed检测主要是对相关字符串做了比对，如下图所示：
在做完比对后返回0和1进行比较，最后又会调用那个自己写的p39D681EED99DC7E506A9D4E07BD58D3A函数，前面提到，该函数功能类似kill，此处做了重命名为p3_linux_syscal_kill。
6. Hook检测之substrace检测
通过静态分析可知，pAFD3E6E79D2F88D9F3563AE570866D51函数在case2中调用了pB4DACEC3279252082ECED1471A664BF7函数，此函数则为substrace的检测点，
具体函数如下所示：
当然也是比较的字符串，根据以上信息可以在手机中安装对应的框架进行动态验证，由于我的环境没有安装该hook框架，故暂未进行动态验证。
7.小结
根据以上分析，过掉以上反调试就很容易了，具体操作不难，不再赘述，方法可以参考帖子【2】。我采用idapython脚本绕过，终于可以开心的调试了，以上当然不是所有的反调，具体还有其他细节的处理遇到了再根据具体情况加以分析，其中还有inotify没有分析，具体可以参考另一篇帖子【3】。当然，对于梆梆壳这只是迈出的第一步，还有很多内容等待我们去挖掘！
8.参考引用
*本文原创作者：y0nLandroid，本文属FreeBuf原创奖励计划，未经许可禁止转载